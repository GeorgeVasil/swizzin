#!/bin/bash

function install_rar() {
	if [[ -z $(which rar) ]]; then
		apt_install rar unrar
	fi
}

function _rar() {
	cd /tmp
	wget -q http://www.rarlab.com/rar/rarlinux-x64-5.5.0.tar.gz
	tar -xzf rarlinux-x64-5.5.0.tar.gz > /dev/null 2>&1
	cp rar/*rar /bin > /dev/null 2>&1
	rm -rf rarlinux*.tar.gz > /dev/null 2>&1
	rm -rf /tmp/rar > /dev/null 2>&1
}

# Returns a password for a user in case one exists.
# If password is not found, returns with error code 1
function _get_user_password() {
	user_to_get="$1"
	password=''

	for file in $(find /root/ -maxdepth 1 -name '*.info' | sort); do
		if [[ -f $file ]]; then
			user_in_file=$(cat $file | cut -d: -f1)
			if [ "$user_in_file" = "$user_to_get" ]; then
				password="$(cat $file | cut -d: -f2)"
				break
			fi
		fi
	done

	if [[ -z $password ]]; then
		return 1
	fi
	echo "$password"
}

# OLD way to get users from htpasswd
# Rather wouldn't use this as 3rd party applications migh be playing with this as well
# function _get_user_list () {
#     users=($(cut -d: -f1 < /etc/htpasswd))
# }

#Returns all users managed by swizzin as a newline separated list
function _get_user_list() {
	output=""
	for file in $(find /root/ -maxdepth 1 -name '*.info' ! -name .master.info | sort); do
		if [[ -f $file ]]; then
			output+="$(cut -d: -f1 < "$file")\n"
		fi
	done
	output+=$(cut -d: -f1 < /root/.master.info)
	echo -e "$output" | sort | uniq
}

#Returns the username of the master
function _get_master_username() {
	cut -d: -f1 < /root/.master.info
}

# Removes a file or a directory in case it exists
function rm_if_exists() {
	path="$1"
	if [[ -e "$path" ]]; then
		rm -rf "$path"
	fi
}

function port() {
	LOW_BOUND=$1
	UPPER_BOUND=$2
	comm -23 <(seq ${LOW_BOUND} ${UPPER_BOUND} | sort) <(ss -Htan | awk '{print $4}' | cut -d':' -f2 | sort -u) | shuf | head -n 1
}

function check_ram() {
	if [[ -z $1 ]]; then
		echo_error "Must specify a value to compare"
		return 1
	fi
	if ! dpkg -s bc > /dev/null 2>&1; then
		apt_install bc
	fi
	ramtotal=$(grep MemTotal /proc/meminfo | awk '{print $2}')
	swaptotal=$(grep SwapTotal /proc/meminfo | awk '{print $2}')
	total=$(echo "$swaptotal + $ramtotal" | bc -l | numfmt --from-unit=1024)
	needs=$(echo $1 | numfmt --from=iec)
	if [[ $needs -gt $total ]]; then
		false
	else
		true
	fi
}

function tmp_swap_on() {
	echo_progress_start "Setup is enabling the use of a temporary 2GB swap file"
	dd if=/dev/zero of=/.swapfile bs=1M count=2048 > /dev/null 2>&1 || {
		echo_error "Cannot continue with install because swap file could not be created. Does device have 2GB of free space?"
		exit 1
	}
	mkswap /.swapfile > /dev/null 2>&1
	swapon /.swapfile > /dev/null 2>&1
	echo_progress_done 'Swap enabled'
}

function tmp_swap_off() {
	swapoff /.swapfile > /dev/null 2>&1
	rm -f /.swapfile > /dev/null 2>&1
}

# Will recurse if $pass isn't set or isn't valid
function password_check() {
	#If no password set, then get one
	if [[ -z $pass ]]; then
		while [[ -z $confirmedPass ]]; do
			if [[ $1 = "whiptail" ]]; then
				pass=$(whiptail --passwordbox "Enter new password for $user. Leave empty to generate." 9 40 3>&1 1>&2 2>&3)
				exitstatus=$?
				if [ "$exitstatus" = 1 ]; then exit 0; fi
			else
				echo_query "Enter password for ${user}. (leave empty to generate a password)" "hidden"
				read -rs 'pass'
				echo
			fi
			if [[ $pass = "" ]]; then
				#If password should be generated, skip the check
				confirmedPass=true
			else
				if [[ $1 = "whiptail" ]]; then
					pass2=$(whiptail --passwordbox "Please confirm the password" 9 40 3>&1 1>&2 2>&3)
					exitstatus=$?
					if [ "$exitstatus" = 1 ]; then exit 0; fi
				else
					echo_query "Please confirm password" "hidden"
					read -rs 'pass2'
					echo
				fi
				if [[ $pass != "$pass2" ]]; then
					if [[ $1 = "whiptail" ]]; then
						whiptail --title "Error" --msgbox "Passwords did not match." --ok-button="Try again" 10 50
					else
						echo_warn "Passwords did not match. Press enter to try again"
						read -n 1 -r
					fi
				else
					confirmedPass=true
				fi
			fi
		done
		unset confirmedPass
	fi

	if [[ -z "${pass}" ]]; then
		echo_progress_start "Generating password"
		pass="$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c16)"
		whiptail --title "Generated password" --msgbox "The generated password for $user is:\n$pass \n\nNote this down as this will not be shown again after it is hidden" --ok-button="Hide" 10 70
		echo_progress_done "Password generated and hidden"
	fi

	#Perform tests. If failure is detected, recurse by unsetting $pass, and running `password_check $1`
	##Cracklib test
	if [[ -n $(which cracklib-check) ]]; then
		echo_progress_start "Checking password strength"
		result=$(cracklib-check <<< "$pass")
		if ! grep -q OK <<< "$result"; then
			result=""
			unset result
			if [[ $1 = "whiptail" ]]; then
				whiptail --title "Error" --msgbox "Password did not pass cracklib check." --ok-button="Try again" 10 50
			else
				echo_warn "Password did not pass cracklib check. Press enter to try again"
				read -n 1 -r
			fi
			pass=
			unset pass
			password_check "$1"
		else
			echo_progress_done "Password passed"
		fi

	fi
}

# Will recurse while $user isn't set or isn't valid
function username_check() {
	if [[ -z $user ]]; then
		if [[ $1 = "whiptail" ]]; then
			user=$(whiptail --inputbox "Enter username for Swizzin \"master\"" 8 40 3>&1 1>&2 2>&3)
			exitstatus=$?
			if [ "$exitstatus" = 1 ]; then exit 0; fi
		else
			echo_query "Enter a name for the new user"
			read -r user
		fi
	fi

	#Perform tests. If failure is set message and set flag
	## Quick caps check
	error_message=""
	if [[ $user =~ [A-Z] ]]; then
		error_message+="Usernames must not contain capital letters.\n"
		badUsername=true
	fi
	## Check reserved usernames
	if [[ $user =~ ("swizzin"|"admin"|"www-data"|"root") ]]; then
		error_message+="$user is a reserved username -- please use something else.\n"
		badUsername=true
	fi
	## Do the complicated regex
	if ! [[ $user =~ ^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\$)$ ]]; then
		error_message+="Usernames must conform to this regex ^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\\$)$.\n"
		badUsername=true
	fi
	## Recurse if error found
	if [[ $badUsername = "true" ]]; then
		if [[ $1 = "whiptail" ]]; then
			whiptail --title "Error" --msgbox "$error_message" --ok-button="Try again" 12 50
		else
			echo_warn "$error_message. Press enter to try again"
			read -n 1 -r
		fi
		user=
		badUsername=false
		username_check "$1"
	fi
}
