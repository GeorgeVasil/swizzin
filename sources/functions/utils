#!/bin/bash

function install_rar() {
	if [[ -z $(which rar) ]]; then
		apt_install rar unrar
	fi
}

function _rar() {
	cd /tmp
	wget -q http://www.rarlab.com/rar/rarlinux-x64-5.5.0.tar.gz
	tar -xzf rarlinux-x64-5.5.0.tar.gz > /dev/null 2>&1
	cp rar/*rar /bin > /dev/null 2>&1
	rm -rf rarlinux*.tar.gz > /dev/null 2>&1
	rm -rf /tmp/rar > /dev/null 2>&1
}

# Returns a password for a user in case one exists.
# If password is not found, returns with error code 1
function _get_user_password() {
	user_to_get="$1"
	password=''

	for file in $(find /root/ -maxdepth 1 -name '*.info' | sort); do
		if [[ -f $file ]]; then
			user_in_file=$(cat $file | cut -d: -f1)
			if [ "$user_in_file" = "$user_to_get" ]; then
				password="$(cat $file | cut -d: -f2)"
				break
			fi
		fi
	done

	if [[ -z $password ]]; then
		return 1
	fi
	echo "$password"
}

# OLD way to get users from htpasswd
# Rather wouldn't use this as 3rd party applications migh be playing with this as well
# function _get_user_list () {
#     users=($(cut -d: -f1 < /etc/htpasswd))
# }

#Returns all users managed by swizzin as a newline separated list
function _get_user_list() {
	output=""
	for file in $(find /root/ -maxdepth 1 -name '*.info' ! -name .master.info | sort); do
		if [[ -f $file ]]; then
			output+="$(cut -d: -f1 < "$file")\n"
		fi
	done
	output+=$(cut -d: -f1 < /root/.master.info)
	echo -e "$output" | sort | uniq
}

#Returns the username of the master
function _get_master_username() {
	cut -d: -f1 < /root/.master.info
}

# Removes a file or a directory in case it exists
function rm_if_exists() {
	path="$1"
	if [[ -e "$path" ]]; then
		rm -rf "$path"
	fi
}

function port() {
	LOW_BOUND=$1
	UPPER_BOUND=$2
	comm -23 <(seq ${LOW_BOUND} ${UPPER_BOUND} | sort) <(ss -Htan | awk '{print $4}' | cut -d':' -f2 | sort -u) | shuf | head -n 1
}

function check_ram() {
	if [[ -z $1 ]]; then
		echo_error "Must specify a value to compare"
		return 1
	fi
	if ! dpkg -s bc > /dev/null 2>&1; then
		apt_install bc
	fi
	ramtotal=$(grep MemTotal /proc/meminfo | awk '{print $2}')
	swaptotal=$(grep SwapTotal /proc/meminfo | awk '{print $2}')
	total=$(echo "$swaptotal + $ramtotal" | bc -l | numfmt --from-unit=1024)
	needs=$(echo $1 | numfmt --from=iec)
	if [[ $needs -gt $total ]]; then
		false
	else
		true
	fi
}

function tmp_swap_on() {
	echo_progress_start "Setup is enabling the use of a temporary 2GB swap file"
	dd if=/dev/zero of=/.swapfile bs=1M count=2048 > /dev/null 2>&1 || {
		echo_error "Cannot continue with install because swap file could not be created. Does device have 2GB of free space?"
		exit 1
	}
	mkswap /.swapfile > /dev/null 2>&1
	swapon /.swapfile > /dev/null 2>&1
	echo_progress_done 'Swap enabled'
}

function tmp_swap_off() {
	swapoff /.swapfile > /dev/null 2>&1
	rm -f /.swapfile > /dev/null 2>&1
}

# Will recurse if $pass isn't set or isn't valid
function password_check(){
    #If no password set, then get one 
    if [[ $pass = "" ]]; then
        if [[ $1 = "whiptail" ]]; then
            while [[ -z $password_ok ]]; do
                pass=$(whiptail --passwordbox "Enter new password for $user. Leave empty to generate." 9 40 3>&1 1>&2 2>&3); exitstatus=$?; if [ "$exitstatus" = 1 ]; then exit 0; fi
                if [[ $pass = "" ]]; then
                    #Password should be random
                    password_ok=true
        else
                    pass2=$(whiptail --passwordbox "Please confirm the password" 9 40 3>&1 1>&2 2>&3); exitstatus=$?; if [ "$exitstatus" = 1 ]; then exit 0; fi
                    if [[ $pass != $pass2 ]];then
                        whiptail --title "Error" --msgbox "Passwords did not match." --ok-button="Try again" 10 50
                    else
                        password_ok=true
                    fi
                fi
            done
        else
            while [[ -z $password_ok ]]; do
            echo_query "Enter password for ${user}. (leave empty to generate a password)" "hidden"
                read -rs 'pass'; echo
                if [[ $pass = "" ]]; then
                    #Password should be random
                    password_ok=true
                else
                    echo_query "Please confirm password" "hidden"
                    read -rs 'pass2'; echo
                    if [[ $pass != $pass2 ]];then
                        if [[ $1 = "whiptail" ]]; then 
                            whiptail --title "Error" --msgbox "Passwords did not match." --ok-button="Try again" 10 50
                        else
                        echo_warn "Passwords did not match. Press enter to try again"
                            read -n 1 -r
                        fi
                    else
                        password_ok=true
                    fi
                fi
            done
            unset password_ok
        fi

        if [[ -z "${pass}" ]]; then
            echo_progress_start "Generating password"
            pass="$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c16)"
                whiptail --title "Generated password" --msgbox "The generated password for $user is:\n$pass \n\nNote this down as this will not be shown again after it is hidden" --ok-button="Hide" 10 70
            echo_progress_done "Password generated and hidden"
        fi
    fi

    #Perform tests. If failure is detected, recurse by unsetting $pass, and running `password_check $1`
    ##Cracklib test
        if [[ -n $(which cracklib-check) ]]; then 
        echo_progress_start "Checking password strength."
        if ! grep -q OK <<< cracklib-check <<< "$pass"; then
            if [[ $1 = "whiptail" ]]; then
                whiptail --title "Error" --msgbox "Passwords did not match." --ok-button="Try again" 10 50
            else
                echo_warn "Password did not pass cracklib check. Press enter to try again"
                read -n 1 -r
            fi
                pass=
            unset pass
            password_check "$1"
        else
        echo_progress_done "Password passed"
        fi

    fi
}

# Will recurse while $user isn't set or isn't valid
function username_check(){
    if [[ -z $user ]]; then
        if [[ $1 = "whiptail" ]]; then 
            user=$(whiptail --inputbox "Enter username for Swizzin \"master\"" 8 40 3>&1 1>&2 2>&3); exitstatus=$?; if [ "$exitstatus" = 1 ]; then exit 0; fi
        else
            # echo_log_only "username not whiptailed? where did this call come from?"
            echo_query "Enter a username for the new user"
            read -r user
        fi
    fi

    #Perform tests. If failure is detected, recurse by unsetting $user, and running `username_check $1`

    ## Quick caps check
    error_message=""
        if [[ $user =~ [A-Z] ]]; then
        error_message+="Usernames must not contain capital letters.\n"
        usernamebad=true
    fi

    ## Check reserved usernames
    if [[ $user =~ ("swizzin"|"admin"|"www-data"|"root") ]]; then
        error_message+="$user is a reserved username -- please use something else.\n"
        usernamebad=true
    fi

    ## Do the complicated regex
    if ! [[ $user =~ ^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\$)$ ]]; then
        error_message+="Usernames must conform to this regex ^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\\$)$.\n"
        usernamebad=true
    fi

    if [[ $usernamebad = "true" ]]; then 
        if [[ $1 = "whiptail" ]]; then
            whiptail --title "Error" --msgbox "$error_message" --ok-button="Try again" 12 50
        else
            echo_warn "$error_message. Press enter to try again"
            read -n 1 -r
        fi
        user=
        username_check "$1"
        fi

}